use crate::target_ir::TargetIr;

pub fn generate_cli_js(target: &TargetIr) -> String {
  let mut out = String::new();
  let target_json = serde_json::to_string(target).unwrap_or_else(|_| "{}".to_string());

  out.push_str("// Auto-generated by sculpt (cli)\n\n");
  out.push_str(&format!("const TARGET = {};\n\n", target_json));
  out.push_str("const VIEWS = TARGET.views || {};\n");
  out.push_str("const FLOW = TARGET.flow || { start: '', transitions: {} };\n");
  out.push_str("let state = FLOW.start || '';\n\n");
  out.push_str("const EXT = TARGET.extensions || {};\n");
  out.push_str("const RUNTIME_RULES = Array.isArray(EXT.runtimeRules) ? EXT.runtimeRules : [];\n");
  out.push_str("const RUNTIME_STATE = (TARGET.state && typeof TARGET.state === 'object') ? JSON.parse(JSON.stringify(TARGET.state)) : {};\n");

  out.push_str("const COLORS = {\n");
  out.push_str("  black: '\\x1b[30m', red: '\\x1b[31m', green: '\\x1b[32m', yellow: '\\x1b[33m',\n");
  out.push_str("  blue: '\\x1b[34m', magenta: '\\x1b[35m', cyan: '\\x1b[36m', white: '\\x1b[37m'\n");
  out.push_str("};\n");
  out.push_str("const RESET = '\\x1b[0m';\n\n");

  out.push_str("function inferBuiltinGame() {\n");
  out.push_str("  if (EXT && EXT.game && EXT.game.kind) return EXT.game;\n");
  out.push_str("  const texts = [];\n");
  out.push_str("  for (const items of Object.values(VIEWS)) {\n");
  out.push_str("    for (const item of items || []) {\n");
  out.push_str("      if (item && item.kind === 'text' && typeof item.text === 'string') texts.push(item.text.toUpperCase());\n");
  out.push_str("    }\n");
  out.push_str("  }\n");
  out.push_str("  const hasPlayState = !!(FLOW.transitions && FLOW.transitions.Play);\n");
  out.push_str("  const isBreakout = texts.some((t) => t.includes('BREAKOUT')) && hasPlayState;\n");
  out.push_str("  if (isBreakout) {\n");
  out.push_str("    return {\n");
  out.push_str("      kind: 'breakout',\n");
  out.push_str("      width: Number(RUNTIME_STATE.width || 42),\n");
  out.push_str("      height: Number(RUNTIME_STATE.height || 22),\n");
  out.push_str("      paddleWidth: Number(RUNTIME_STATE.paddleWidth || 7),\n");
  out.push_str("      tickMs: Number(RUNTIME_STATE.speedMs || 60),\n");
  out.push_str("      lives: Number(RUNTIME_STATE.lives || 3),\n");
  out.push_str("      brickRows: 5,\n");
  out.push_str("      brickCols: 8,\n");
  out.push_str("      brickWidth: 4,\n");
  out.push_str("      gap: 1\n");
  out.push_str("    };\n");
  out.push_str("  }\n");
  out.push_str("  const isSnake = texts.some((t) => t.includes('SNAKE')) && hasPlayState;\n");
  out.push_str("  if (isSnake) {\n");
  out.push_str("    return {\n");
  out.push_str("      kind: 'snake',\n");
  out.push_str("      width: Number(RUNTIME_STATE.width || 16),\n");
  out.push_str("      height: Number(RUNTIME_STATE.height || 12),\n");
  out.push_str("      tickMs: Number(RUNTIME_STATE.speedMs || 120)\n");
  out.push_str("    };\n");
  out.push_str("  }\n");
  out.push_str("  return null;\n");
  out.push_str("}\n\n");

  out.push_str("const GAME_SPEC = inferBuiltinGame();\n");
  out.push_str("let game = null;\n");
  out.push_str("let tickHandle = null;\n\n");

  out.push_str("function createBreakout(spec) {\n");
  out.push_str("  const width = Math.max(30, Number(spec.width || 42));\n");
  out.push_str("  const height = Math.max(16, Number(spec.height || 22));\n");
  out.push_str("  const paddleWidth = Math.max(3, Number(spec.paddleWidth || 7));\n");
  out.push_str("  const lives = Math.max(1, Number(spec.lives || 3));\n");
  out.push_str("  const brickRows = Math.max(1, Number(spec.brickRows || 5));\n");
  out.push_str("  const brickCols = Math.max(2, Number(spec.brickCols || 8));\n");
  out.push_str("  const brickWidth = Math.max(2, Number(spec.brickWidth || 4));\n");
  out.push_str("  const gap = Math.max(0, Number(spec.gap || 1));\n");
  out.push_str("  const innerWidth = width - 2;\n");
  out.push_str("  const totalBricksWidth = brickCols * brickWidth + (brickCols - 1) * gap;\n");
  out.push_str("  const leftPad = Math.max(1, Math.floor((innerWidth - totalBricksWidth) / 2));\n");
  out.push_str("  const bricks = [];\n");
  out.push_str("  for (let r = 0; r < brickRows; r += 1) {\n");
  out.push_str("    for (let c = 0; c < brickCols; c += 1) {\n");
  out.push_str("      bricks.push({ x: 1 + leftPad + c * (brickWidth + gap), y: 2 + r, w: brickWidth, alive: true });\n");
  out.push_str("    }\n");
  out.push_str("  }\n");
  out.push_str("  const paddleY = height - 2;\n");
  out.push_str("  const paddleX = Math.floor((width - paddleWidth) / 2);\n");
  out.push_str("  return {\n");
  out.push_str("    width,\n");
  out.push_str("    height,\n");
  out.push_str("    paddleWidth,\n");
  out.push_str("    paddleY,\n");
  out.push_str("    paddleX,\n");
  out.push_str("    ballX: paddleX + Math.floor(paddleWidth / 2),\n");
  out.push_str("    ballY: paddleY - 1,\n");
  out.push_str("    vx: 1,\n");
  out.push_str("    vy: -1,\n");
  out.push_str("    launched: false,\n");
  out.push_str("    score: 0,\n");
  out.push_str("    lives,\n");
  out.push_str("    won: false,\n");
  out.push_str("    bricks,\n");
  out.push_str("    tickMs: Math.max(20, Number(spec.tickMs || 60))\n");
  out.push_str("  };\n");
  out.push_str("}\n\n");

  out.push_str("function createSnake(spec) {\n");
  out.push_str("  const width = Math.max(10, Number(spec.width || 16));\n");
  out.push_str("  const height = Math.max(8, Number(spec.height || 12));\n");
  out.push_str("  const cx = Math.floor(width / 2);\n");
  out.push_str("  const cy = Math.floor(height / 2);\n");
  out.push_str("  const snake = [\n");
  out.push_str("    { x: cx, y: cy },\n");
  out.push_str("    { x: cx - 1, y: cy },\n");
  out.push_str("    { x: cx - 2, y: cy }\n");
  out.push_str("  ];\n");
  out.push_str("  const s = {\n");
  out.push_str("    kind: 'snake',\n");
  out.push_str("    width,\n");
  out.push_str("    height,\n");
  out.push_str("    tickMs: Math.max(40, Number(spec.tickMs || 120)),\n");
  out.push_str("    snake,\n");
  out.push_str("    direction: 'right',\n");
  out.push_str("    pendingDirection: 'right',\n");
  out.push_str("    score: 0,\n");
  out.push_str("    alive: true,\n");
  out.push_str("    food: null\n");
  out.push_str("  };\n");
  out.push_str("  s.food = placeFood(s);\n");
  out.push_str("  return s;\n");
  out.push_str("}\n\n");

  out.push_str("function placeFood(s) {\n");
  out.push_str("  const occ = new Set(s.snake.map((p) => `${p.x},${p.y}`));\n");
  out.push_str("  const free = [];\n");
  out.push_str("  for (let y = 1; y < s.height - 1; y += 1) {\n");
  out.push_str("    for (let x = 1; x < s.width - 1; x += 1) {\n");
  out.push_str("      const key = `${x},${y}`;\n");
  out.push_str("      if (!occ.has(key)) free.push({ x, y });\n");
  out.push_str("    }\n");
  out.push_str("  }\n");
  out.push_str("  if (free.length === 0) return null;\n");
  out.push_str("  return free[Math.floor(Math.random() * free.length)];\n");
  out.push_str("}\n\n");

  out.push_str("function enterPlayState() {\n");
  out.push_str("  if (!GAME_SPEC) return;\n");
  out.push_str("  if (GAME_SPEC.kind === 'breakout') {\n");
  out.push_str("    game = createBreakout(GAME_SPEC);\n");
  out.push_str("  } else if (GAME_SPEC.kind === 'snake') {\n");
  out.push_str("    game = createSnake(GAME_SPEC);\n");
  out.push_str("  }\n");
  out.push_str("}\n\n");

  out.push_str("function ensureGameInit() {\n");
  out.push_str("  if (!GAME_SPEC || game) return;\n");
  out.push_str("  enterPlayState();\n");
  out.push_str("}\n\n");

  out.push_str("function resetBall() {\n");
  out.push_str("  game.ballX = game.paddleX + Math.floor(game.paddleWidth / 2);\n");
  out.push_str("  game.ballY = game.paddleY - 1;\n");
  out.push_str("  game.vx = game.vx >= 0 ? 1 : -1;\n");
  out.push_str("  game.vy = -1;\n");
  out.push_str("  game.launched = false;\n");
  out.push_str("}\n\n");

  out.push_str("function stepBreakout() {\n");
  out.push_str("  if (!game || game.kind !== 'breakout' || state !== 'Play') return;\n");
  out.push_str("  if (!game.launched) {\n");
  out.push_str("    game.ballX = game.paddleX + Math.floor(game.paddleWidth / 2);\n");
  out.push_str("    game.ballY = game.paddleY - 1;\n");
  out.push_str("    return;\n");
  out.push_str("  }\n");
  out.push_str("  let nx = game.ballX + game.vx;\n");
  out.push_str("  let ny = game.ballY + game.vy;\n");
  out.push_str("  if (nx <= 1 || nx >= game.width - 2) {\n");
  out.push_str("    game.vx *= -1;\n");
  out.push_str("    nx = game.ballX + game.vx;\n");
  out.push_str("  }\n");
  out.push_str("  if (ny <= 1) {\n");
  out.push_str("    game.vy *= -1;\n");
  out.push_str("    ny = game.ballY + game.vy;\n");
  out.push_str("  }\n");
  out.push_str("  if (ny >= game.height - 1) {\n");
  out.push_str("    game.lives -= 1;\n");
  out.push_str("    if (game.lives <= 0) {\n");
  out.push_str("      dispatch('done');\n");
  out.push_str("      return;\n");
  out.push_str("    }\n");
  out.push_str("    resetBall();\n");
  out.push_str("    return;\n");
  out.push_str("  }\n");
  out.push_str("  if (game.vy > 0 && ny === game.paddleY - 1 && nx >= game.paddleX && nx < game.paddleX + game.paddleWidth) {\n");
  out.push_str("    const center = game.paddleX + (game.paddleWidth - 1) / 2;\n");
  out.push_str("    const offset = nx - center;\n");
  out.push_str("    game.vx = offset < 0 ? -1 : 1;\n");
  out.push_str("    if (offset === 0) game.vx = Math.random() < 0.5 ? -1 : 1;\n");
  out.push_str("    game.vy = -1;\n");
  out.push_str("    ny = game.ballY + game.vy;\n");
  out.push_str("  }\n");
  out.push_str("  let hitBrick = false;\n");
  out.push_str("  for (const b of game.bricks) {\n");
  out.push_str("    if (!b.alive) continue;\n");
  out.push_str("    if (ny === b.y && nx >= b.x && nx < b.x + b.w) {\n");
  out.push_str("      b.alive = false;\n");
  out.push_str("      game.score += 10;\n");
  out.push_str("      game.vy *= -1;\n");
  out.push_str("      hitBrick = true;\n");
  out.push_str("      ny = game.ballY + game.vy;\n");
  out.push_str("      break;\n");
  out.push_str("    }\n");
  out.push_str("  }\n");
  out.push_str("  if (!hitBrick && game.bricks.every((b) => !b.alive)) {\n");
  out.push_str("    game.won = true;\n");
  out.push_str("    dispatch('done');\n");
  out.push_str("    return;\n");
  out.push_str("  }\n");
  out.push_str("  game.ballX = nx;\n");
  out.push_str("  game.ballY = ny;\n");
  out.push_str("}\n\n");

  out.push_str("function handleGameInput(event) {\n");
  out.push_str("  if (!game || state !== 'Play') return;\n");
  out.push_str("  if (game.kind === 'breakout' && (event === 'key(a)' || event === 'key(left)')) {\n");
  out.push_str("    game.paddleX = Math.max(1, game.paddleX - 2);\n");
  out.push_str("  } else if (game.kind === 'breakout' && (event === 'key(d)' || event === 'key(right)')) {\n");
  out.push_str("    game.paddleX = Math.min(game.width - 1 - game.paddleWidth, game.paddleX + 2);\n");
  out.push_str("  } else if (game.kind === 'breakout' && event === 'key(space)') {\n");
  out.push_str("    game.launched = true;\n");
  out.push_str("  } else if (game.kind === 'snake') {\n");
  out.push_str("    if ((event === 'key(w)' || event === 'key(up)') && game.direction !== 'down') game.pendingDirection = 'up';\n");
  out.push_str("    if ((event === 'key(s)' || event === 'key(down)') && game.direction !== 'up') game.pendingDirection = 'down';\n");
  out.push_str("    if ((event === 'key(a)' || event === 'key(left)') && game.direction !== 'right') game.pendingDirection = 'left';\n");
  out.push_str("    if ((event === 'key(d)' || event === 'key(right)') && game.direction !== 'left') game.pendingDirection = 'right';\n");
  out.push_str("  }\n");
  out.push_str("}\n\n");

  out.push_str("function renderBreakout() {\n");
  out.push_str("  const grid = Array.from({ length: game.height }, () => Array.from({ length: game.width }, () => ' '));\n");
  out.push_str("  for (let x = 0; x < game.width; x += 1) { grid[0][x] = '#'; grid[game.height - 1][x] = '#'; }\n");
  out.push_str("  for (let y = 0; y < game.height; y += 1) { grid[y][0] = '#'; grid[y][game.width - 1] = '#'; }\n");
  out.push_str("  for (const b of game.bricks) {\n");
  out.push_str("    if (!b.alive) continue;\n");
  out.push_str("    for (let x = b.x; x < b.x + b.w; x += 1) grid[b.y][x] = '=';\n");
  out.push_str("  }\n");
  out.push_str("  for (let x = game.paddleX; x < game.paddleX + game.paddleWidth; x += 1) grid[game.paddleY][x] = '_';\n");
  out.push_str("  if (game.ballY > 0 && game.ballY < game.height - 1 && game.ballX > 0 && game.ballX < game.width - 1) {\n");
  out.push_str("    grid[game.ballY][game.ballX] = 'o';\n");
  out.push_str("  }\n");
  out.push_str("  console.log(COLORS.cyan + `Score: ${game.score}   Lives: ${game.lives}` + RESET);\n");
  out.push_str("  for (const row of grid) console.log(row.join(''));\n");
  out.push_str("}\n\n");

  out.push_str("function stepSnake() {\n");
  out.push_str("  if (!game || game.kind !== 'snake' || state !== 'Play' || !game.alive) return;\n");
  out.push_str("  game.direction = game.pendingDirection || game.direction;\n");
  out.push_str("  const head = game.snake[0];\n");
  out.push_str("  let nx = head.x;\n");
  out.push_str("  let ny = head.y;\n");
  out.push_str("  if (game.direction === 'up') ny -= 1;\n");
  out.push_str("  if (game.direction === 'down') ny += 1;\n");
  out.push_str("  if (game.direction === 'left') nx -= 1;\n");
  out.push_str("  if (game.direction === 'right') nx += 1;\n");
  out.push_str("  if (nx <= 0 || nx >= game.width - 1 || ny <= 0 || ny >= game.height - 1) {\n");
  out.push_str("    game.alive = false;\n");
  out.push_str("    dispatch('done');\n");
  out.push_str("    return;\n");
  out.push_str("  }\n");
  out.push_str("  for (const p of game.snake) {\n");
  out.push_str("    if (p.x === nx && p.y === ny) {\n");
  out.push_str("      game.alive = false;\n");
  out.push_str("      dispatch('done');\n");
  out.push_str("      return;\n");
  out.push_str("    }\n");
  out.push_str("  }\n");
  out.push_str("  game.snake.unshift({ x: nx, y: ny });\n");
  out.push_str("  const ate = game.food && game.food.x === nx && game.food.y === ny;\n");
  out.push_str("  if (ate) {\n");
  out.push_str("    game.score += 1;\n");
  out.push_str("    game.food = placeFood(game);\n");
  out.push_str("  } else {\n");
  out.push_str("    game.snake.pop();\n");
  out.push_str("  }\n");
  out.push_str("  if (!game.food) {\n");
  out.push_str("    dispatch('done');\n");
  out.push_str("  }\n");
  out.push_str("}\n\n");

  out.push_str("function renderSnake() {\n");
  out.push_str("  const grid = Array.from({ length: game.height }, () => Array.from({ length: game.width }, () => ' '));\n");
  out.push_str("  for (let x = 0; x < game.width; x += 1) { grid[0][x] = '#'; grid[game.height - 1][x] = '#'; }\n");
  out.push_str("  for (let y = 0; y < game.height; y += 1) { grid[y][0] = '#'; grid[y][game.width - 1] = '#'; }\n");
  out.push_str("  if (game.food) grid[game.food.y][game.food.x] = '*';\n");
  out.push_str("  for (let i = 0; i < game.snake.length; i += 1) {\n");
  out.push_str("    const p = game.snake[i];\n");
  out.push_str("    grid[p.y][p.x] = i === 0 ? '@' : 'o';\n");
  out.push_str("  }\n");
  out.push_str("  console.log(COLORS.cyan + `Score: ${game.score}   Length: ${game.snake.length}` + RESET);\n");
  out.push_str("  for (const row of grid) console.log(row.join(''));\n");
  out.push_str("}\n\n");

  out.push_str("function startTicker() {\n");
  out.push_str("  if (tickHandle) return;\n");
  out.push_str("  const ms = game ? game.tickMs : Math.max(20, Number(((EXT.runtime || {}).tickMs) || 80));\n");
  out.push_str("  tickHandle = setInterval(() => {\n");
  out.push_str("    dispatch('tick');\n");
  out.push_str("    if (game && game.kind === 'breakout') stepBreakout();\n");
  out.push_str("    if (game && game.kind === 'snake') stepSnake();\n");
  out.push_str("    if (game) render();\n");
  out.push_str("  }, ms);\n");
  out.push_str("}\n\n");

  out.push_str("function stopTicker() {\n");
  out.push_str("  if (tickHandle) {\n");
  out.push_str("    clearInterval(tickHandle);\n");
  out.push_str("    tickHandle = null;\n");
  out.push_str("  }\n");
  out.push_str("}\n\n");

  out.push_str("function stateNeedsTick(s) {\n");
  out.push_str("  const map = (FLOW.transitions && FLOW.transitions[s]) || {};\n");
  out.push_str("  if (Object.prototype.hasOwnProperty.call(map, 'tick')) return true;\n");
  out.push_str("  for (const rule of RUNTIME_RULES) {\n");
  out.push_str("    if (!rule || rule.on !== 'tick') continue;\n");
  out.push_str("    if (rule.scopeState && rule.scopeState !== s) continue;\n");
  out.push_str("    return true;\n");
  out.push_str("  }\n");
  out.push_str("  return false;\n");
  out.push_str("}\n\n");

  out.push_str("function resolveRuntimeValue(v) {\n");
  out.push_str("  if (v && typeof v === 'object' && !Array.isArray(v) && typeof v.ident === 'string') {\n");
  out.push_str("    return RUNTIME_STATE[v.ident];\n");
  out.push_str("  }\n");
  out.push_str("  return v;\n");
  out.push_str("}\n\n");

  out.push_str("function evalWhen(when) {\n");
  out.push_str("  if (!when || typeof when !== 'object') return false;\n");
  out.push_str("  if (when.kind === 'logic') {\n");
  out.push_str("    if (when.op === 'and') return evalWhen(when.left) && evalWhen(when.right);\n");
  out.push_str("    if (when.op === 'or') return evalWhen(when.left) || evalWhen(when.right);\n");
  out.push_str("    return false;\n");
  out.push_str("  }\n");
  out.push_str("  const mode = when.kind === 'cmp' ? when.op : when.op;\n");
  out.push_str("  if (mode === 'gte') {\n");
  out.push_str("    const left = Number(RUNTIME_STATE[String(when.left)] || 0);\n");
  out.push_str("    const right = Number(resolveRuntimeValue(when.right) || 0);\n");
  out.push_str("    return left >= right;\n");
  out.push_str("  }\n");
  out.push_str("  if (mode === 'gt') {\n");
  out.push_str("    const left = Number(RUNTIME_STATE[String(when.left)] || 0);\n");
  out.push_str("    const right = Number(resolveRuntimeValue(when.right) || 0);\n");
  out.push_str("    return left > right;\n");
  out.push_str("  }\n");
  out.push_str("  if (mode === 'lt') {\n");
  out.push_str("    const left = Number(RUNTIME_STATE[String(when.left)] || 0);\n");
  out.push_str("    const right = Number(resolveRuntimeValue(when.right) || 0);\n");
  out.push_str("    return left < right;\n");
  out.push_str("  }\n");
  out.push_str("  if (mode === 'eq') {\n");
  out.push_str("    const left = RUNTIME_STATE[String(when.left)];\n");
  out.push_str("    const right = resolveRuntimeValue(when.right);\n");
  out.push_str("    if (typeof left === 'number' || typeof right === 'number') {\n");
  out.push_str("      return Number(left || 0) === Number(right || 0);\n");
  out.push_str("    }\n");
  out.push_str("    return String(left) === String(right);\n");
  out.push_str("  }\n");
  out.push_str("  if (mode === 'neq') {\n");
  out.push_str("    const left = RUNTIME_STATE[String(when.left)];\n");
  out.push_str("    const right = resolveRuntimeValue(when.right);\n");
  out.push_str("    if (typeof left === 'number' || typeof right === 'number') {\n");
  out.push_str("      return Number(left || 0) !== Number(right || 0);\n");
  out.push_str("    }\n");
  out.push_str("    return String(left) !== String(right);\n");
  out.push_str("  }\n");
  out.push_str("  return false;\n");
  out.push_str("}\n\n");

  out.push_str("function applyRuntimeRules(event, firedWhen) {\n");
  out.push_str("  const emitted = [];\n");
  out.push_str("  for (const rule of RUNTIME_RULES) {\n");
  out.push_str("    if (!rule) continue;\n");
  out.push_str("    if (rule.scopeState && rule.scopeState !== state) continue;\n");
  out.push_str("    const isOnRule = typeof rule.on === 'string' && rule.on.length > 0;\n");
  out.push_str("    const isWhenRule = !!rule.when;\n");
  out.push_str("    if (isOnRule && rule.on !== event) continue;\n");
  out.push_str("    if (isWhenRule) {\n");
  out.push_str("      if (firedWhen && firedWhen.has(rule.name)) continue;\n");
  out.push_str("      if (!evalWhen(rule.when)) continue;\n");
  out.push_str("      if (firedWhen) firedWhen.add(rule.name);\n");
  out.push_str("    }\n");
  out.push_str("    if (!isOnRule && !isWhenRule) continue;\n");
  out.push_str("    const assigns = Array.isArray(rule.assign) ? rule.assign : [];\n");
  out.push_str("    for (const a of assigns) {\n");
  out.push_str("      if (!a || typeof a.target !== 'string') continue;\n");
  out.push_str("      const value = resolveRuntimeValue(a.value);\n");
  out.push_str("      if (a.op === 'add') {\n");
  out.push_str("        const cur = Number(RUNTIME_STATE[a.target] || 0);\n");
  out.push_str("        const add = Number(value || 0);\n");
  out.push_str("        RUNTIME_STATE[a.target] = cur + add;\n");
  out.push_str("      } else {\n");
  out.push_str("        RUNTIME_STATE[a.target] = value;\n");
  out.push_str("      }\n");
  out.push_str("    }\n");
  out.push_str("    const emits = Array.isArray(rule.emit) ? rule.emit : [];\n");
  out.push_str("    for (const ev of emits) {\n");
  out.push_str("      if (typeof ev === 'string' && ev.length > 0) emitted.push(ev);\n");
  out.push_str("    }\n");
  out.push_str("  }\n");
  out.push_str("  return emitted;\n");
  out.push_str("}\n\n");

  out.push_str("function render() {\n");
  out.push_str("  console.clear();\n");
  out.push_str("  if (game && state === 'Play') {\n");
  out.push_str("    if (game.kind === 'breakout') renderBreakout();\n");
  out.push_str("    if (game.kind === 'snake') renderSnake();\n");
  out.push_str("    return;\n");
  out.push_str("  }\n");
  out.push_str("  const items = VIEWS[state] || [];\n");
  out.push_str("  for (const item of items) {\n");
  out.push_str("    if (item.kind === 'text') {\n");
  out.push_str("      const color = item.color ? (COLORS[item.color] || '') : '';\n");
  out.push_str("      console.log(color + (item.text || '') + RESET);\n");
  out.push_str("    }\n");
  out.push_str("  }\n");
  out.push_str("}\n\n");

  out.push_str("function processEvent(event, depth, firedWhen) {\n");
  out.push_str("  if (depth > 24) return;\n");
  out.push_str("  if (!firedWhen) firedWhen = new Set();\n");
  out.push_str("  const before = state;\n");
  out.push_str("  if (game) handleGameInput(event);\n");
  out.push_str("  const map = (FLOW.transitions && FLOW.transitions[state]) || {};\n");
  out.push_str("  if (map[event]) state = map[event];\n");
  out.push_str("  const emitted = applyRuntimeRules(event, firedWhen);\n");
  out.push_str("  if (state !== before && state === 'Play') {\n");
  out.push_str("    enterPlayState();\n");
  out.push_str("  }\n");
  out.push_str("  if (stateNeedsTick(state)) {\n");
  out.push_str("    startTicker();\n");
  out.push_str("  } else {\n");
  out.push_str("    stopTicker();\n");
  out.push_str("  }\n");
  out.push_str("  if (state !== before && String(state).toLowerCase() === 'exit') process.exit(0);\n");
  out.push_str("  if (state !== before) render();\n");
  out.push_str("  for (const ev of emitted) processEvent(ev, depth + 1, firedWhen);\n");
  out.push_str("}\n\n");

  out.push_str("function dispatch(event) {\n");
  out.push_str("  processEvent(event, 0, new Set());\n");
  out.push_str("}\n\n");

  out.push_str("function normalizeKey(key) {\n");
  out.push_str("  if (key === '\\r' || key === '\\n' || key.includes('\\r') || key.includes('\\n')) return 'enter';\n");
  out.push_str("  if (key === '\\u001b') return 'esc';\n");
  out.push_str("  if (key === '\\u001b[A') return 'up';\n");
  out.push_str("  if (key === '\\u001b[B') return 'down';\n");
  out.push_str("  if (key === '\\u001b[D') return 'left';\n");
  out.push_str("  if (key === '\\u001b[C') return 'right';\n");
  out.push_str("  if (key === ' ') return 'space';\n");
  out.push_str("  return key.trim().toLowerCase();\n");
  out.push_str("}\n\n");

  out.push_str("ensureGameInit();\n");
  out.push_str("if (stateNeedsTick(state)) startTicker();\n");
  out.push_str("render();\n");
  out.push_str("if (process.stdin.isTTY) process.stdin.setRawMode(true);\n");
  out.push_str("process.stdin.resume();\n");
  out.push_str("process.stdin.on('data', (buf) => {\n");
  out.push_str("  const key = buf.toString('utf8');\n");
  out.push_str("  if (key === '\\u0003') process.exit(0);\n");
  out.push_str("  const k = normalizeKey(key);\n");
  out.push_str("  dispatch(`key(${k})`);\n");
  out.push_str("});\n");

  out
}
