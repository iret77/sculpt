use std::collections::HashMap;
use std::io::Write;
use std::path::Path;
use std::process::{Command, Stdio};

use anyhow::{bail, Context, Result};
use serde_json::{json, Value};

use crate::codegen::cli::generate_cli_js;
use crate::codegen::web::generate_web_js;
use crate::ir::{to_pretty_json, IrModule};
use crate::target_ir::TargetIr;

pub enum TargetKind {
  Cli,
  Web,
  Cpp,
  External(String),
}

pub fn resolve_target(name: &str) -> TargetKind {
  match name {
    "cli" => TargetKind::Cli,
    "web" => TargetKind::Web,
    "cpp" => TargetKind::Cpp,
    other => TargetKind::External(other.to_string()),
  }
}

pub fn run_external_target(
  target: &str,
  ir: &IrModule,
  nd_outputs: Option<&HashMap<String, Value>>,
  target_ir: Option<&Value>,
  out_dir: &Path,
  input_path: &Path,
  lock: Option<Value>,
  mode: &str,
) -> Result<()> {
  let exe = format!("sculpt-target-{}", target);
  let payload = json!({
    "mode": mode,
    "ir": serde_json::to_value(ir)?,
    "irPretty": to_pretty_json(ir)?,
    "ndOutputs": nd_outputs,
    "targetIr": target_ir,
    "outDir": out_dir,
    "input": input_path,
    "lock": lock,
  });

  let mut child = Command::new(&exe)
    .stdin(Stdio::piped())
    .stdout(Stdio::inherit())
    .stderr(Stdio::inherit())
    .spawn()
    .with_context(|| format!("Failed to launch target provider: {}", exe))?;

  if let Some(mut stdin) = child.stdin.take() {
    let data = serde_json::to_vec(&payload)?;
    stdin.write_all(&data)?;
  }

  let status = child.wait()?;
  if !status.success() {
    bail!("Target provider {} failed with status {:?}", exe, status.code());
  }
  Ok(())
}

pub fn emit_web(target: &TargetIr, out_dir: &Path) -> Result<()> {
  std::fs::create_dir_all(out_dir)?;
  std::fs::write(out_dir.join("main.js"), generate_web_js(target))?;
  let html = r#"<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sculpt Web Target</title>
    <style>
      body { font-family: sans-serif; padding: 24px; }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <script src="main.js"></script>
  </body>
</html>
"#;
  std::fs::write(out_dir.join("index.html"), html)?;
  Ok(())
}

pub fn emit_cpp(target: &TargetIr, out_dir: &Path) -> Result<()> {
  std::fs::create_dir_all(out_dir)?;
  let mut cpp = String::new();
  cpp.push_str("// Auto-generated by sculpt (cpp target)\n");
  cpp.push_str("#include <iostream>\n#include <string>\n\n");
  cpp.push_str("int main() {\n");
  cpp.push_str("  std::cout << \"SCULPT GUI target stub\" << std::endl;\n");
  cpp.push_str("  std::cout << \"Start state: \" << ");
  cpp.push_str(&format!("\"{}\";\n", target.flow.start));
  cpp.push_str("  std::cout << std::endl;\n");
  cpp.push_str("  return 0;\n}\n");
  std::fs::write(out_dir.join("main.cpp"), cpp)?;
  Ok(())
}

pub fn emit_cli(target: &TargetIr, out_dir: &Path) -> Result<()> {
  std::fs::create_dir_all(out_dir)?;
  std::fs::write(out_dir.join("main.js"), generate_cli_js(target))?;
  Ok(())
}

pub fn run_web(out_dir: &Path) -> Result<()> {
  let index = out_dir.join("index.html");
  if !index.exists() {
    bail!("dist/index.html not found. Run `sculpt build --target web <file>` first.");
  }
  if Command::new("open").arg(&index).status().is_ok() {
    return Ok(());
  }
  if Command::new("xdg-open").arg(&index).status().is_ok() {
    return Ok(());
  }
  if Command::new("cmd").args(["/c", "start"]).arg(&index).status().is_ok() {
    return Ok(());
  }
  bail!("Could not auto-open browser. Open dist/index.html manually.");
}

pub fn run_cpp(out_dir: &Path) -> Result<()> {
  let exe = out_dir.join("app");
  if !exe.exists() {
    bail!("dist/app not found. Compile dist/main.cpp first (e.g. `g++ dist/main.cpp -std=c++17 -o dist/app`).");
  }
  let status = Command::new(exe).status()?;
  if !status.success() {
    bail!("cpp run failed with status {:?}", status.code());
  }
  Ok(())
}

pub fn run_cli(out_dir: &Path) -> Result<()> {
  let entry = out_dir.join("main.js");
  if !entry.exists() {
    bail!("dist/main.js not found. Run `sculpt build --target cli <file>` first.");
  }
  let status = Command::new("node")
    .arg(entry)
    .status()
    .with_context(|| "Failed to run cli target (node dist/main.js)")?;
  if !status.success() {
    bail!("cli run failed with status {:?}", status.code());
  }
  Ok(())
}

pub fn list_targets() -> Result<Vec<String>> {
  let mut targets = vec![
    "cli".to_string(),
    "web".to_string(),
    "cpp".to_string(),
  ];

  if let Some(path_var) = std::env::var_os("PATH") {
    for dir in std::env::split_paths(&path_var) {
      if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
          if let Some(name) = entry.file_name().to_str() {
            if let Some(rest) = name.strip_prefix("sculpt-target-") {
              if !rest.is_empty() {
                targets.push(rest.to_string());
              }
            }
          }
        }
      }
    }
  }

  targets.sort();
  targets.dedup();
  Ok(targets)
}

pub fn describe_target(name: &str) -> Result<Value> {
  match resolve_target(name) {
    TargetKind::Web => builtin_spec("web-ir", include_str!("../../ir-schemas/web-ir.json")),
    TargetKind::Cli => builtin_spec("cli-ir", include_str!("../../ir-schemas/cli-ir.json")),
    TargetKind::Cpp => builtin_spec("gui-ir", include_str!("../../ir-schemas/gui-ir.json")),
    TargetKind::External(t) => external_describe(&t),
  }
}

fn builtin_spec(standard_ir: &str, schema: &str) -> Result<Value> {
  let schema_json: Value = serde_json::from_str(schema)?;
  Ok(json!({
    "standard_ir": standard_ir,
    "schema": schema_json,
    "extensions": {}
  }))
}

fn external_describe(target: &str) -> Result<Value> {
  let exe = format!("sculpt-target-{}", target);
  let output = Command::new(&exe)
    .arg("describe")
    .output()
    .with_context(|| format!("Failed to launch target provider: {}", exe))?;
  if !output.status.success() {
    bail!("Target provider {} describe failed", exe);
  }
  let value: Value = serde_json::from_slice(&output.stdout)?;
  Ok(value)
}
